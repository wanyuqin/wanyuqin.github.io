<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>My New Hugo Site</title>
<meta name="keywords" content="">
<meta name="description" content="数据类型
​	处理数据类型是软件工程师经常要进行的操作。本章深入探讨与基本类型、切片和映射相关的最常见错误。我们省略的唯一数据类型是字符串，因为后面的章节专门讨论这种类型。

与八进制文件混淆
​	让我们首先看一下八进制文字表示的常见误解，这可能导致混淆甚至错误。您认为以下代码的输出应该是什么？
sum := 100 &#43; 010
fmt.Println(sum)
​	乍一看，我们可能希望这段代码打印 100 &#43; 10 = 110 的结果。但它打印的却是 108。这怎么可能？
​	在 Go 中，以 0 开头的整数文字被视为八进制整数（以 8 为底），因此以 8 为底的 10 等于以 10 为底的 8。因此，上一个示例中的和等于 100 &#43; 8 = 108。这是一个记住整数文字的重要属性——例如，避免在阅读现有代码时混淆。
​	八进制整数在不同的场景中很有用。例如，假设我们想使用 os.OpenFile 打开一个文件。此函数需要将权限作为 uint32 传递。如果我们想要匹配一个 Linux 权限，我们可以传递一个八进制数以提高可读性，而不是一个基数为 10 的数字：
file, err := os.OpenFile(&#34;foo&#34;, os.O_RDONLY, 0644)
​	在此示例中，0644 表示特定的 Linux 权限（对所有用户读取，对当前用户仅写入）。也可以在零后面添加一个 o 字符（小写字母 o）
file, err := os.OpenFile(&#34;foo&#34;, os.O_RDONLY, 0o644)
​	使用 0o 作为前缀而不是仅使用 0 意味着同样的事情。但是，它可以帮助让代码更清晰。
​	我们也可以使用大写字母 O 代替小写字母 o。但是传递 0O644 会增加混淆，因为根据字符字体，0 可能看起来与 O 非常相似。">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/100_go_mistack/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/100_go_mistack/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="数据类型">数据类型<a hidden class="anchor" aria-hidden="true" href="#数据类型">#</a></h1>
<p>​	处理数据类型是软件工程师经常要进行的操作。本章深入探讨与基本类型、切片和映射相关的最常见错误。我们省略的唯一数据类型是字符串，因为后面的章节专门讨论这种类型。</p>
<!-- raw HTML omitted -->
<h2 id="与八进制文件混淆">与八进制文件混淆<a hidden class="anchor" aria-hidden="true" href="#与八进制文件混淆">#</a></h2>
<p>​	让我们首先看一下八进制文字表示的常见误解，这可能导致混淆甚至错误。您认为以下代码的输出应该是什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">sum</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">010</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">sum</span>)
</span></span></code></pre></div><p>​	乍一看，我们可能希望这段代码打印 100 + 10 = 110 的结果。但它打印的却是 108。这怎么可能？</p>
<p>​	在 Go 中，以 0 开头的整数文字被视为八进制整数（以 8 为底），因此以 8 为底的 10 等于以 10 为底的 8。因此，上一个示例中的和等于 100 + 8 = 108。这是一个记住整数文字的重要属性——例如，避免在阅读现有代码时混淆。</p>
<p>​	八进制整数在不同的场景中很有用。例如，假设我们想使用 os.OpenFile 打开一个文件。此函数需要将权限作为 uint32 传递。如果我们想要匹配一个 Linux 权限，我们可以传递一个八进制数以提高可读性，而不是一个基数为 10 的数字：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">OpenFile</span>(<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_RDONLY</span>, <span style="color:#ae81ff">0644</span>)
</span></span></code></pre></div><p>​	在此示例中，0644 表示特定的 Linux 权限（对所有用户读取，对当前用户仅写入）。也可以在零后面添加一个 o 字符（小写字母 o）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">OpenFile</span>(<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_RDONLY</span>, <span style="color:#ae81ff">0</span><span style="color:#a6e22e">o644</span>)
</span></span></code></pre></div><p>​	使用 0o 作为前缀而不是仅使用 0 意味着同样的事情。但是，它可以帮助让代码更清晰。</p>
<p>​	<code>我们也可以使用大写字母 O 代替小写字母 o。但是传递 0O644 会增加混淆，因为根据字符字体，0 可能看起来与 O 非常相似。</code></p>
<p>​	我们还应该注意其他整数文字表示：</p>
<ul>
<li>二进制：使用 0b 或 0B 前缀（例如，0b100 等于以 10 为基数的 4）</li>
<li>十六进制：使用 0x 或 0X 前缀（例如，0xF 等于 10 进制的 15）</li>
<li><em>Imaginary</em>：使用 i 后缀（例如 3i）</li>
</ul>
<p>​	最后，为了便于阅读，我们还可以使用下划线字符 (_) 作为分隔符。比如我们可以这样写10亿：1_000_000_000。我们还可以将下划线字符与其他表示形式一起使用（例如，0b00_00_01）。
​	总之，Go 可以处理二进制、十六进制、虚数和八进制数。八进制数字以 0 开头。但是，为了提高可读性并避免未来代码阅读器可能犯的错误，请使用 0o 前缀明确八进制数字。
​	下一节将深入探讨整数，我们将讨论 Go 中如何处理溢出。</p>
<h2 id="忽略整数溢出">忽略整数溢出<a hidden class="anchor" aria-hidden="true" href="#忽略整数溢出">#</a></h2>
<p>​	不了解 Go 中如何处理整数溢出会导致严重错误。本节深入探讨这个主题。但首先，让我们先了解一些与整数相关的概念。</p>
<h3 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h3>
<p>​	Go 总共提供了 10 种整数类型。有四种有符号整数类型和四种无符号整数类型，如下表所示</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221213203727876.png" alt="image-20221213203727876"  />
</p>
<p>​	其他两种整数类型是最常用的：int 和 uint。这两种类型的大小取决于系统：32 位系统上的 32 位或 64 位系统上的 64 位
​	现在让我们讨论溢出。假设我们要将一个 int32 初始化为其最大值，然后递增它。这段代码的行为应该是什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int32</span> = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counter</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;counter=%d\n&#34;</span>, <span style="color:#a6e22e">counter</span>)
</span></span></code></pre></div><p>​	这段代码可以编译并且不会在运行时出现 panic。但是，counter++ 语句会产生整数溢出:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">counter</span>=<span style="color:#f92672">-</span><span style="color:#ae81ff">2147483648</span>
</span></span></code></pre></div><p>​	当算术运算创建的值超出可以用给定字节数表示的范围时，就会发生整数溢出。 int32 使用 32 位表示。这是最大 int32 值 (math.MaxInt32) 的二进制表示</p>
<pre tabindex="0"><code>01111111111111111111111111111111
 |------31 bits set to 1-------|
</code></pre><p>​	因为 int32 是有符号整数，所以左边的位代表整数的符号：0 表示正数，1 表示负数。如果我们增加这个整数，就没有剩余空间来表示新值。因此，这会导致整数溢出。二进制方面，这是新值：</p>
<pre tabindex="0"><code>10000000000000000000000000000000
 |------31 bits set to 0-------|
</code></pre><p>​	正如我们所见，位符号现在等于 1，表示负数。该值是用 32 位表示的带符号整数的最小可能值。</p>
<p>​	在 Go 中，可以在编译时检测到的整数溢出会生成一个编译错误。例如，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int32</span> = <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">constant</span> <span style="color:#ae81ff">2147483648</span> <span style="color:#a6e22e">overflows</span> <span style="color:#66d9ef">int32</span>
</span></span></code></pre></div><p>​	但是，在运行时，整数上溢或下溢是无声的；这不会导致应用程序恐慌。必须牢记这种行为，因为它可能导致偷偷摸摸的错误（例如，整数增量或正整数相加导致负结果）。</p>
<p>​	在深入研究如何使用常见操作检测整数溢出之前，让我们考虑一下何时需要关注它。在大多数情况下，比如处理请求的计数器或基本的加法/乘法，如果我们使用正确的整数类型，我们就不必太担心。但在某些情况下，例如使用较小整数类型的内存受限项目、处理大数字或进行转换，我们可能希望检查可能的溢出。</p>
<h3 id="递增时检测整数溢出">递增时检测整数溢出<a hidden class="anchor" aria-hidden="true" href="#递增时检测整数溢出">#</a></h3>
<p>​	如果我们想在基于定义大小的类型（int8、int16、int32、int64、uint8、uint16、uint32 或 uint64）的增量操作期间检测整数溢出，我们可以根据数学常量检查该值。例如，对于 int32:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Inc32</span>(<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int32</span>) <span style="color:#66d9ef">int32</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span> (<span style="color:#e6db74">&#34;int32 overflow&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	此函数检查输入是否已经等于 math.MaxInt32。如果是这样的情况，那么程序就会Panic</p>
<p>​	int 和 uint 类型呢？在 Go 1.17 之前，我们必须手动构建这些常量。现在，math.MaxInt、math.MinInt 和 math.MaxUint 是 math 包的一部分。如果我们必须测试 int 类型的溢出，我们可以使用 math.MaxInt 来完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IncInt</span>(<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt</span> {
</span></span><span style="display:flex;"><span>        panic(<span style="color:#e6db74">&#34;int overflow&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	uint 的逻辑相同。我们可以使用 math.MaxUint：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">IncUint</span>(<span style="color:#a6e22e">counter</span> <span style="color:#66d9ef">uint</span>) <span style="color:#66d9ef">uint</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxUint</span> {
</span></span><span style="display:flex;"><span>        panic(<span style="color:#e6db74">&#34;uint overflow&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	在本节中，我们学习了如何检查增量操作后的整数溢出。现在，加法呢？</p>
<h3 id="在加法过程中检测整数溢出">在加法过程中检测整数溢出<a hidden class="anchor" aria-hidden="true" href="#在加法过程中检测整数溢出">#</a></h3>
<p>​	我们如何检测加法过程中的整数溢出？答案是重用 math.MaxInt：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">AddInt</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">b</span> {
</span></span><span style="display:flex;"><span>     panic(<span style="color:#e6db74">&#34;int overflow&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	在示例中，a 和 b 是两个操作数。如果 a 大于 math.MaxInt - b，运算将导致整数溢出。现在，让我们看一下乘法运算。</p>
<h3 id="在乘法期间检测整数溢出">在乘法期间检测整数溢出<a hidden class="anchor" aria-hidden="true" href="#在乘法期间检测整数溢出">#</a></h3>
<p>​	乘法处理起来有点复杂。我们必须对最小整数 math.MinInt 执行检查：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MultiplyInt</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span> 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MinInt</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MinInt</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#e6db74">&#34;integer overflow&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">result</span><span style="color:#f92672">/</span><span style="color:#a6e22e">b</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">a</span> {
</span></span><span style="display:flex;"><span>    panic(<span style="color:#e6db74">&#34;integer overflow&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	用乘法检查整数溢出需要多个步骤。首先，我们需要测试其中一个操作数是否等于 0、1 或 math.MinInt,然后我们将乘法结果除以 b。如果结果不等于原始因子（a），则表示发生了整数溢出。</p>
<p>​	总之，整数溢出（和下溢）在 Go 中是静默操作。如果我们想检查溢出以避免隐藏的错误，我们可以使用本节中描述的实用函数。还要记住 Go 提供了一个包来处理大数：math/big。如果 int 不够用，这可能是一个选择。</p>
<p>​	我们将在下一节中继续讨论基本的 Go 类型和浮点数。</p>
<h2 id="浮点数">浮点数<a hidden class="anchor" aria-hidden="true" href="#浮点数">#</a></h2>
<p>​	在 Go 中，有两种浮点类型（如果我们省略虚数）：float32 和 float64。发明浮点数的概念是为了解决整数的主要问题：它们无法表示分数值。为避免意外，我们需要知道浮点运算是实数运算的近似值。让我们检查一下使用近似值的影响以及如何提高准确性。为此，我们将看一个乘法示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">float32</span> = <span style="color:#ae81ff">1.0001</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">n</span>)
</span></span></code></pre></div><p>​	我们可能希望这段代码打印出 1.0001 * 1.0001 = 1.00020001 的结果，对吧？但是，在大多数 x86 处理器上运行它会打印 1.0002，我们怎么解释呢？我们需要先了解浮点数的运算。</p>
<p>​	我们以 float64 类型为例。请注意，在 math.SmallestNonzeroFloat64（float64 最小值）和 math.MaxFloat64（float64 最大值）之间存在无限数量的实数值。相反，float64 类型的位数是有限的：64。因为让无限值适合有限空间是不可能的，所以我们必须使用近似值。因此，我们可能会失去精度。 float32 类型的逻辑相同。</p>
<p>​	Go 中的浮点数遵循 IEEE-754 标准，一些位代表尾数，其他位代表指数。尾数是基值，而指数是应用于尾数的乘数。在单精度浮点类型（float32）中，8 位表示指数，23 位表示尾数。在双精度浮点类型 (float64) 中，指数和尾数的值分别为 11 位和 52 位。剩余的位用于符号。要将浮点数转换为小数，我们使用以下计算：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">sign</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>^<span style="color:#a6e22e">exponent</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">mantissa</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223153112293.png" alt="image-20221223153112293"  />
</p>
<p>​	上图说明了 1.0001 作为 float32 的表示。指数使用 8 位超额/偏置表示法：01111111 指数值表示 2^0，而尾数等于 1.000100016593933。 （请注意，本节的范围不解释转换的工作原理。）因此，十进制值等于 1 × 2^0 × 1.000100016593933。因此，我们存储在单精度浮点值中的不是 1.0001，而是 1.000100016593933。缺乏精度会影响存储值的准确性。</p>
<p>​	一旦我们理解了 float32 和 float64 是近似值，对我们开发人员有何启示？第一个含义与比较有关。使用 == 运算符比较两个浮点数可能会导致不准确。相反，我们应该比较它们的差异，看它是否小于某个小误差值。例如，testify 测试库 (<a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a>) 有一个 InDelta 函数来断言两个值在给定的彼此增量内。
还要记住，浮点计算的结果取决于实际的处理器。大多数处理器都有一个浮点单元 (FPU) 来处理此类计算。不能保证在一台机器上执行的结果在另一台具有不同 FPU 的机器上是相同的。使用增量比较两个值可以成为跨不同机器实施有效测试的解决方案。</p>
<p><strong>浮点数的种类</strong></p>
<p>Go 还有三种特殊的浮点数：</p>
<ul>
<li>正无穷大</li>
<li>负无穷大</li>
<li>NaN (Not-a-Number)，这是一个未定义或不可表示的结果</li>
</ul>
<p>​	根据 IEEE-754，NaN 是唯一满足 f != f 的浮点数。下面是构造这些特殊类型数字的示例以及输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">positiveInf</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">negativeInf</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">nan</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">positiveInf</span>, <span style="color:#a6e22e">negativeInf</span>, <span style="color:#a6e22e">nan</span>)
</span></span></code></pre></div><p>我们可以使用 math.IsInf 检查浮点数是否无限，使用 math.IsNaN 检查它是否为 NaN</p>
<p>​	到目前为止，我们已经看到小数到浮点数的转换会导致精度下降。 这是由于转换引起的错误。 另请注意，错误可能会在一系列浮点运算中累积。</p>
<p>​	让我们看一个例子，其中有两个函数以不同的顺序执行相同的操作序列。 在我们的示例中，f1 首先将 float64 初始化为 10,000，然后将 1.0001 重复添加到该结果（n 次）。 相反，f2 以相反的顺序执行相同的操作（最后添加 10,000）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">10_000</span>.
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">result</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1.0001</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f2</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">result</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1.0001</span>
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10_000</span>.
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>​	现在，让我们在 x86 处理器上运行这些函数。 然而，这一次，我们将改变 n</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223153937874.png" alt="image-20221223153937874"  />
</p>
<p>​	请注意，n 越大，不精确性越大。 但是，我们也可以看到 f2 的精度优于 f1。 请记住，浮点计算的顺序会影响结果的准确性。
在执行一系列加法和减法时，我们应该先对具有相似数量级的值进行加减操作，然后再对数量级不相近的值进行加减操作。 因为 f2 加上 10,000，所以最终它产生的结果比 f1 更准确</p>
<p>​	乘法和除法呢？ 假设我们要计算以下内容：</p>
<p>​	<code>a × (b + c)</code></p>
<p>​	正如我们所知，这个计算等于</p>
<p>​	<code>a×b+a×c</code></p>
<p>让我们使用与 b 不同数量级的 a 来运行这两个计算和c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100000.001</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0001</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1.0002</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">c</span> ))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#a6e22e">b</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">*</span><span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200030.00200030004</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200030.0020003</span>
</span></span></code></pre></div><p>​	确切的结果是 200,030.002。 因此，第一个计算的准确性最差。 事实上，在进行涉及加减乘除的浮点计算时，我们必须先完成乘除运算才能获得更好的精度。 有时，这可能会影响执行时间（在前面的示例中，它需要三个操作而不是两个）。 在那种情况下，它是准确性和执行时间之间的选择。</p>
<p>​	Go 的 float32 和 float64 是近似值。 因此，我们必须牢记一些规则</p>
<ul>
<li>比较两个浮点数时，检查它们的差异是否在可接受的范围内</li>
<li>执行加法或减法时，将具有相似数量级的运算分组以获得更好的准确性。</li>
<li>为了保证准确性，如果一系列运算需要加、减、乘或除，请先执行乘除运算。</li>
</ul>
<h2 id="切片长度和容量">切片长度和容量<a hidden class="anchor" aria-hidden="true" href="#切片长度和容量">#</a></h2>
<p>​	Go 开发人员混合切片长度和容量或者不完全理解它们是很常见的。 吸收这两个概念对于有效处理核心操作至关重要，例如切片初始化和通过追加、复制或切片添加元素。 这种误解会导致切片使用不理想甚至内存泄漏（我们将在后面的部分中看到）。</p>
<p>​	在 Go 中，切片由数组支持。 这意味着切片的数据连续存储在数组数据结构中。 切片还具有处理在后备数组已满时添加元素或在后备数组几乎为空时缩小后备数组的逻辑。</p>
<p>​	在内部，切片包含指向后备数组的指针以及长度和容量。 长度是切片包含的元素数，而容量是后备数组中的元素数。 让我们通过几个例子来使事情更清楚。 首先，让我们初始化一个给定长度和容量的切片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>) <span style="color:#75715e">// length=3 capacity=6
</span></span></span></code></pre></div><p>​	第一个参数，代表长度，是一个必需要的参数。第二个参数表示容量，是一个可选的参数</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223160804697.png" alt="image-20221223160804697"  />
</p>
<p>​	在这个例子中，make创建了一个六个元素（容量）的数组。但是因为长度设置为3，Go只初始化了前三个元素。此外，因为切片是int类型，前三个与元素被初始化为int的零值：0,图中灰色的元素表示已经分配但是尚未使用</p>
<p>​	如果我们打印这个切片，我们会得到长度范围内的元素，[0 0 0]。 如果我们将 s[1] 设置为 1，则切片的第二个元素会更新而不会影响其长度或容量。 下图，说明了这一点</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223161820981.png" alt="image-20221223161820981"  />
</p>
<p>​	但是，禁止访问超出长度范围的元素，即使它已经在内存中分配。 例如，s[4] = 0 会导致以下恐慌</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">panic</span>: <span style="color:#a6e22e">runtime</span> <span style="color:#66d9ef">error</span>: <span style="color:#a6e22e">index</span> <span style="color:#a6e22e">out</span> <span style="color:#a6e22e">of</span> <span style="color:#66d9ef">range</span> [<span style="color:#ae81ff">4</span>] <span style="color:#a6e22e">with</span> <span style="color:#a6e22e">length</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>​	我们如何使用切片的剩余空间？ 通过使用 append 内置函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p>​	此代码向现有的s切片追加一个新元素，它使用第一个灰色元素（已分配但尚未使用）来存储元素2</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223162853210.png" alt="image-20221223162853210"  />
</p>
<p>​	切片长度从3更新为4，因为现在切片包含了四个元素。如果我们再添加三个元素已致后备数据不够大会发生什么</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">3</span> ,<span style="color:#ae81ff">4</span> ,<span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
</span></span></code></pre></div><p>​	如果我们运行上面的代码。我们会看到切片可以处理我们的请求：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>[<span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">5</span>]
</span></span></code></pre></div><p>​	因为数组是固定大小的结构，它可以存储新元素直到元素 4。当我们要插入元素 5 时，数组已经满了。这个时候在Go的内部会创建另一个容量双倍的数组。然后把之前的数组元素进行复制，最后将5插入</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223163819311.png" alt="image-20221223163819311"  />
</p>
<p><code>注意 在 Go 中，切片通过将其大小加倍来增长，直到它包含 1024 个元素，之后它增长 25%</code></p>
<p>​	现在切片引用了新的数组，对于之前的数组，它将不会被应用。如果它被分配到了堆上，那么最终会被垃圾收集器（GC）释放</p>
<p>​	在进行切片切割的时候会发生什么？对于切割是针对切片和数组的操作，是左闭右开的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>] 
</span></span></code></pre></div><p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223170143907.png" alt="image-20221223170143907"  />
</p>
<p>​	首先，将s1创建为长度为3，容量为6的切片。当通过切片s1创建s2时，两个切片都引用了相同的底层数组。但是，s2从不同的索引1开始。因此，它的长度和容量（一个长度为2、容量为5的切片)与s1不同。如果我们更新s1[1]或者s2[0],更改是对同一个数组进行的。因此，在两个切片中都可见</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223170446490.png" alt="image-20221223170446490"  />
</p>
<p>​	现在，如果我们将一个元素附加到s2会发生什么。s1是否也会被更改</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s2</span> = append(<span style="color:#a6e22e">s2</span>, <span style="color:#ae81ff">2</span>)
</span></span></code></pre></div><p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223171134672.png" alt="image-20221223171134672"  />
</p>
<p>​	这个时候只有s2的长度发生了变化，s1仍然是一个长度为3、容量为6的切片。因此如果我们打印s1和s2，添加的元素仅对s2可见</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>s1<span style="color:#f92672">=[</span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> 0<span style="color:#f92672">]</span>, s2<span style="color:#f92672">=[</span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span> 2<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>​	理解这种行为很重要，这样我们才不会在使用append时做出错误的假设</p>
<p>​	最后需要注意的一件事，如果我们一直向s2追加元素直到底层数组满了怎么办？在内存方面，状态会是怎么样的？让我们再添加三个元素。</p>
<pre tabindex="0"><code>s2 = append(s2, 3)
s2 = append(s2, 4)
s2 = append(s2, 5)
</code></pre><p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221223172038251.png" alt="image-20221223172038251"  />
</p>
<p>​	上面的代码会导致创建出一个新的底层数组。s1和s2现在引用两个不同的数组。由于s1仍然是一个长度为3，容量为6的切片，它依然有一些可用的缓冲区，所以它一直引用初始数组。新的底层数组是通过从 s2 的第一个索引复制初始数组来创建的。 这就是为什么新数组从元素 1 而不是 0 开始的原因。</p>
<p>​	总而言之，切片长度是切片中可用元素的数量，而切片容量是底层数组中元素的数量。 将一个元素添加到一个完整的切片（长度 == 容量）会导致创建一个具有新容量的新底层数组，复制前一个数组中的所有元素，并将切片指针更新为新数组</p>
<h2 id="效率低的切片初始化">效率低的切片初始化<a hidden class="anchor" aria-hidden="true" href="#效率低的切片初始化">#</a></h2>
<p>​	在使用 make 初始化切片时，我们看到我们必须提供一个长度和一个可选的容量。很多时候忘记为这两个参数传递适当的值是一个普遍的错误。 让我们准确地看看什么时候这被认为是合适的。
​	假设我们要实现一个转换函数，将 Foo 切片映射到 Bar 切片，并且两个切片将具有相同数量的元素。 这是第一个实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>) []<span style="color:#a6e22e">Bar</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bars</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">Bar</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">foo</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">foos</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bars</span> = append(<span style="color:#a6e22e">bars</span>, <span style="color:#a6e22e">fooToBar</span>(<span style="color:#a6e22e">foo</span>))
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bars</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	首先，我们使用 make([]Bar, 0) 初始化一个空的 Bar 元素切片。 然后，我们使用 append 添加 Bar 元素。首先， bars 是空的，所以添加第一个元素的时候需要分配一个大小为1的底层数组。每次底层数组满的时候，Go都会通过将其容量加倍来创建另一个数组。</p>
<p>​	当我们添加第三个元素、第五个、第九个等等时，由于当前数组已满而创建另一个数组的逻辑会重复多次。 假设输入切片有 1,000 个元素，该算法需要分配 10 个后备数组并将总共 1,000 多个元素从一个数组复制到另一个数组。 这导致 GC 需要付出额外的努力来清理所有这些临时支持阵列</p>
<p>​	在性能方面，没有充分的理由不为 Go 运行时提供帮助。 为此有两种不同的选择。 第一个选项是重用相同的代码，但分配具有给定容量的切片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>) []<span style="color:#a6e22e">Bar</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">foos</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bars</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">Bar</span>, <span style="color:#ae81ff">0</span> , <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">foo</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">foos</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">bars</span> = append(<span style="color:#a6e22e">bars</span>, <span style="color:#a6e22e">fooToBar</span>(<span style="color:#a6e22e">foo</span>)) 
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bars</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	唯一的变化是创建容量等于 n（foos 的长度）的 bars。 在内部，Go 预分配了一个包含 n 个元素的数组。 因此，将 n 个元素相加意味着重用相同的后备数组，从而减少分配的次数</p>
<p>​	还有一种方式是分配给定长度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convert</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>) []<span style="color:#a6e22e">Bar</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">foos</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">bars</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">Bar</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">foo</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">foos</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">bars</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">fooToBar</span>(<span style="color:#a6e22e">foo</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bars</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	因为我们用长度初始化切片，n个元素已经分配并初始化Bar的零值。因此，要设置元素我们需要使用<code>bars[i]</code>而不是<code>append</code></p>
<p>​	那种选择最好呢？让我们用以上三个解决方案和100万个元素进行基准测试</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221226165104307.png" alt="image-20221226165104307"  />
</p>
<p>​	正如我们所见，第一个解决方案在性能上有很大的影响，当我们继续分配数组和复制元素时，第一个基准比其他两个慢了近 400%。 比较第二种和第三种方案，第三种方案快了大约 4%，因为我们避免了重复调用内置的 append 函数，与直接赋值相比，它的开销很小</p>
<p>​	如果设置容量并使用追加比设置长度并分配给直接索引效率低，为什么我们会在 Go 项目中看到这种方法？ 让我们看一个由 Cockroach Labs 开发的开源键值存储 Pebble 中的具体示例 <a href="https://github.com/cockroachdb/pebble">https://github.com/cockroachdb/pebble</a></p>
<p>​	一个名为 collectAllUserKeys 的函数需要迭代一个结构片段来格式化一个特定的字节片段。 结果切片将是输入切片长度的两倍</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">collectAllUserKeys</span>(<span style="color:#a6e22e">cmp</span> <span style="color:#a6e22e">Compare</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tombstones</span> []<span style="color:#a6e22e">tombstoneWithLevel</span>) [][]<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keys</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">tombstones</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tombstones</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keys</span> = append(<span style="color:#a6e22e">keys</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Start</span>.<span style="color:#a6e22e">UserKey</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keys</span> = append(<span style="color:#a6e22e">keys</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">End</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>​	在这里，有意识的选择是使用给定的容量并追加。 这是什么道理？ 如果我们使用给定的长度而不是容量，代码将如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">collectAllUserKeys</span>(<span style="color:#a6e22e">cmp</span> <span style="color:#a6e22e">Compare</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tombstones</span> []<span style="color:#a6e22e">tombstoneWithLevel</span>) [][]<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">keys</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">byte</span>, len(<span style="color:#a6e22e">tombstones</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">tombstones</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keys</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>] = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Start</span>.<span style="color:#a6e22e">UserKey</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">keys</span>[<span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">End</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>​	请注意处理切片索引的代码看起来有多复杂。 鉴于此功能对性能不敏感，因此决定支持最容易阅读的选项</p>
<p>​	将一种切片类型转换为另一种切片类型是 Go 开发人员的频繁操作。 正如我们所见，如果未来切片的长度已知，就没有充分的理由先分配一个空切片。 我们的选择是分配给定容量或给定长度的切片。 在这两个解决方案中，我们已经看到第二个往往稍快一些。 但是在某些情况下，使用给定的容量和追加可能更容易实现和阅读。</p>
<p>​	下一节将讨论 nil 和空切片之间的区别，以及为什么它对 Go 开发人员很重要。</p>
<h2 id="空切片和nil">空切片和Nil<a hidden class="anchor" aria-hidden="true" href="#空切片和nil">#</a></h2>
<p>​	Go 开发人员经常混合 nil 和空切片。 我们可能希望根据用例使用一个。 同时，一些依赖包对两者进行了区分。 要精通切片，我们需要确保不混淆这些概念。 在查看示例之前，让我们讨论一些定义：</p>
<ul>
<li>空切片的长度是0</li>
<li>一个切片是nil那么他就等于nil</li>
</ul>
<p>​	现在，让我们看看初始化切片的不同方法。 你能猜出以下代码的输出吗？ 每次，我们都会打印切片是空的还是 nil</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = []string(<span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = []<span style="color:#66d9ef">string</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span> = make([]<span style="color:#66d9ef">string</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">log</span>(<span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d: empty=%t\tnil=%t\n&#34;</span>, <span style="color:#a6e22e">i</span>, len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">s</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	上面的输出是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ae81ff">1</span>: <span style="color:#a6e22e">empty</span>=<span style="color:#66d9ef">true</span>   <span style="color:#66d9ef">nil</span>=<span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>: <span style="color:#a6e22e">empty</span>=<span style="color:#66d9ef">true</span>   <span style="color:#66d9ef">nil</span>=<span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>: <span style="color:#a6e22e">empty</span>=<span style="color:#66d9ef">true</span>   <span style="color:#66d9ef">nil</span>=<span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>: <span style="color:#a6e22e">empty</span>=<span style="color:#66d9ef">true</span>   <span style="color:#66d9ef">nil</span>=<span style="color:#66d9ef">false</span>
</span></span></code></pre></div><p>​	所有切片都是空的，这意味着长度等于 0。因此，一个 nil 切片也是一个空切片。 但是，只有前两个是 nil 切片。 如果我们有多种初始化切片的方法，我们应该选择哪种方法？ 有两点需要注意</p>
<ul>
<li>nil 和空切片之间的主要区别之一在于分配。 初始化一个 nil 切片不需要任何分配，而空切片则不是这样</li>
<li>无论切片是否为 nil，调用 append 内置函数都有效。 例如:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(append(<span style="color:#a6e22e">s1</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">foo</span>))
</span></span></code></pre></div><p>​	因此，如果一个函数返回一个切片，我们不应该像其他语言那样出于防御原因返回一个非 nil 集合。 因为 nil 切片不需要任何分配，所以我们应该倾向于返回 nil 切片而不是空切片。 让我们看看这个函数，它返回一段字符串:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;foo&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bar</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#e6db74">&#34;bar&#34;</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	如果 foo 和 bar 都为假，我们得到一个空切片。 为防止无缘无故分配空切片，我们应该支持选项 1 (var s []string)。 我们可以将选项 4 (make([]string, 0)) 与零长度字符串一起使用，但与选项 1 相比，这样做不会带来任何价值； 它需要分配</p>
<p>​	然而，在我们必须生成一个已知长度的切片的情况下，我们应该使用选项 4，s := make([]string, length)，如本例所示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">intsToStrings</span>(<span style="color:#a6e22e">ints</span> []<span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">ints</span>))
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ints</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	正如我们在上一章中讨论的那样，我们需要在这样的情况下设置长度（或容量）以避免额外的分配和复制，但是示例中还剩两个选项，他们是切片两种不同的初始化方式</p>
<ul>
<li>Option 2  <code>s:= []string(nil)</code></li>
<li>Options 3  <code>s:=[]string{}</code></li>
</ul>
<p>​	选项 2 不是最广泛使用的。 但它可以用作语法糖，因为我们可以在一行中传递一个 nil 切片——例如，使用 append</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> append([]int(<span style="color:#66d9ef">nil</span>), <span style="color:#ae81ff">42</span>)
</span></span></code></pre></div><p>​	如果我们使用选项 1 (vars[]string)，则需要两行代码。 这可能不是有史以来最重要的可读性优化，但仍然值得了解</p>
<p>​	现在，让我们看看选项 3：s := []string{}。 建议使用这种形式来创建具有初始元素的切片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#e6db74">&#34;bar&#34;</span>, <span style="color:#e6db74">&#34;baz&#34;</span>}
</span></span></code></pre></div><p>​	但是，如果我们不需要创建带有初始元素的切片，则不应使用此选项。 它带来了与选项 1 (vars[]string) 相同的好处，只是切片不是 nil； 因此，它需要分配。 因此，应避免没有初始元素的选项 3</p>
<p>​	我们还应该提到一些库区分 nil 和空切片。 例如，encoding/json 包就是这种情况。 以下示例编组两个结构，一个包含 nil 切片，第二个包含非 nil 的空切片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s1</span> []<span style="color:#66d9ef">float32</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">customer1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ID</span>: <span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#a6e22e">Operations</span>: <span style="color:#a6e22e">s1</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">customer1</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">b</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">float32</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">customer2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ID</span>:         <span style="color:#e6db74">&#34;bar&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Operations</span>: <span style="color:#a6e22e">s2</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">customer2</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">b</span>))
</span></span></code></pre></div><p>运行这个例子，注意这两个结构的编组结果是不同的:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;ID&#34;</span>:<span style="color:#e6db74">&#34;foo&#34;</span>,<span style="color:#e6db74">&#34;Operations&#34;</span>:null<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">{</span><span style="color:#e6db74">&#34;ID&#34;</span>:<span style="color:#e6db74">&#34;bar&#34;</span>,<span style="color:#e6db74">&#34;Operations&#34;</span>:<span style="color:#f92672">[]}</span>
</span></span></code></pre></div><p>​	在这里，一个 nil 切片被编组为空元素，而非 nil 的空切片被编组为一个空数组。 如果我们在区分 null 和 [] 的严格 JSON 客户端的上下文中工作，则必须牢记这一区别</p>
<p>​	encoding/json 包并不是标准库中唯一进行这种区分的包。 例如，如果我们比较 nil 和非 nil 空切片，reflect.DeepEqual 返回 false，这是在单元测试上下文中要记住的事情，例如。 无论如何，在使用标准库或外部库时，我们应该确保在使用一个或另一个版本时，我们的代码不会导致意外结果。
​	总而言之，在 Go 中，nil 和空切片是有区别的。 nil 切片等于 nil，而空切片的长度为零。 nil 切片是空的，但空切片不一定是 nil。 同时，一个 nil 切片不需要任何分配</p>
<h2 id="没有正确检查切片是否为空">没有正确检查切片是否为空<a hidden class="anchor" aria-hidden="true" href="#没有正确检查切片是否为空">#</a></h2>
<p>​	我们在上一节中看到 nil 和空切片之间存在区别。 考虑到这些概念，检查切片是否包含元素的惯用方法是什么？ 没有明确的答案可能会导致细微的错误</p>
<p>​	在这个例子中，我们调用了一个返回 float32 切片的 getOperations 函数。 我们只想在切片包含元素时调用句柄函数。 这是第一个（错误的）版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handleOperations</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operations</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getOperations</span>(<span style="color:#a6e22e">id</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">operations</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">operations</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getOperations</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">float32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operations</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">float32</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">operations</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add elements to operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">operations</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	我们通过检查操作切片是否不为零来确定切片是否包含元素。 但是这段代码有一个问题：getOperations 从不返回 nil 切片； 相反，它返回一个空切片。 因此，操作 != nil 检查将始终为真</p>
<p>​	在这种情况下我们该怎么办？ 一种方法可能是修改 getOperations 以在 id 为空时返回 nil 切片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getOperations</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">float32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operations</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">float32</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">id</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add elements to operations
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">operations</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	如果 id 为空，我们不返回操作，而是返回 nil。 这样，我们实施的关于测试切片无效匹配的检查。 但是，这种方法并非在所有情况下都有效——我们并不总是处于可以更改被调用者的上下文中。 例如，如果我们使用外部库，我们不会创建拉取请求只是为了将 empty 更改为 nil 切片</p>
<p>​	那么我们如何检查一个切片是空的还是零呢？ 解决方案是检查长度</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">handleOperations</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">operations</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getOperations</span>(<span style="color:#a6e22e">id</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">operations</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">handle</span>(<span style="color:#a6e22e">operations</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	我们在上一节中提到，根据定义，空切片的长度为零。 同时，nil 切片总是空的。 因此，通过检查切片的长度，我们涵盖了所有场景</p>
<ul>
<li>如果切片是nil，那么切片长度为0</li>
<li>如果切片不是nil但是为空，那么切片长度还是0</li>
</ul>
<p>​	因此，检查长度是最好的选择，因为我们不能总是控制我们调用的函数所采用的方法。 同时，正如 Go wiki 所说，在设计接口时，我们应该避免区分 nil 和空切片，这会导致细微的编程错误。 返回切片时，如果我们返回 nil 或空切片，则既不会产生语义上的差异，也不会产生技术上的差异。 两者对来调用者来说应该意味着同样的事情。 这个原理和map是一样的。 要检查map是否为空，请检查它的长度，而不是它是否为nil</p>
<h2 id="没有正确的进行切片复制">没有正确的进行切片复制<a hidden class="anchor" aria-hidden="true" href="#没有正确的进行切片复制">#</a></h2>
<p>​	copy 内置函数允许将源切片中的元素复制到目标切片中。 虽然它是一个方便的内置函数，但 Go 开发人员有时会误解它。 让我们看一下导致复制错误数量元素的常见错误。
​	在下面的示例中，我们创建一个切片并将其元素复制到另一个切片。 这段代码的输出应该是什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">src</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">dst</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>copy(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">src</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">dst</span>)
</span></span></code></pre></div><p>​	如果我们运行这个例子，它会打印 []，而不是 [0 1 2]。我们哪里出错了？</p>
<p>​	要有效的使用copy，我们必须了解元素的数量</p>
<ul>
<li>源切片的长度</li>
<li>目标切片的长度</li>
</ul>
<p>​	在之前的示例中，src是一个长度为三的切片，但是dest的切片长度为0。因此，copy这个函数会复制最少的元素（3和0之间）选择0，所以结果就是为空</p>
<p>​	如果我们希望可以进行正常的复制，那么目标切片必须要有一个长度，改长度必须大于或者等于源切片的长度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">src</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">dest</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, len(<span style="color:#a6e22e">src</span>))
</span></span><span style="display:flex;"><span>copy(<span style="color:#a6e22e">dst</span> ,<span style="color:#a6e22e">src</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">dst</span>)
</span></span></code></pre></div><p>​	因为我们现在将dst的长度初始化为3，那么就会有3个元素被成功复制，那么就会正常打印出[0 1 2]</p>
<p>​	另外，使用内置函数copy并不是复制切片元素唯一的方案，有需要不同的替代方案，让人知道最多的是使用append</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">src</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span> ,<span style="color:#ae81ff">1</span> ,<span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">dst</span> <span style="color:#f92672">:=</span> append([]int(<span style="color:#66d9ef">nil</span>), <span style="color:#a6e22e">src</span><span style="color:#f92672">...</span>)
</span></span></code></pre></div><p>​	我们将源切片中的元素附加到nil切片中，以上的代码会创建一个长度为3，容量为3的切片副本。这种替代方法的优点是可以在一行中完成所需要的逻辑。然而，使用copy方法更加的地道，也更容易被理解</p>
<p>​	将元素从一个切片复制到另一个切片是一个相当频繁的操作，使用复制时候，我们需要记住，复制到目标的元素数对应于两个切片长度之间的最小值。</p>
<h2 id="使用append的一些意外情况">使用append的一些意外情况<a hidden class="anchor" aria-hidden="true" href="#使用append的一些意外情况">#</a></h2>
<p>​	本节讨论使用append的时候一个常见错误，它在某些情况下会产生意想不到的副作用。在下面的示例中，我们初始化一个s1切片，通过切片s1创建s2，并且通过向s2附加一个元素来创建s3</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s3</span> <span style="color:#f92672">:=</span> append(<span style="color:#a6e22e">s2</span>, <span style="color:#ae81ff">10</span>)
</span></span></code></pre></div><p>​	我们初始化一个包含三个元素的切片s1，s2是通过对s1的截取创建的，然后我们在s3上调用append，这段代码运行之后，三个切片应该是什么样的？</p>
<p>​	在第二行代码创建完s2之后，内存中的两个切片状态如下图所示</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221227154905451.png" alt="image-20221227154905451"  />
</p>
<p>​	s1是一个长度为3，容量为3的切片，而s2是一个长度为2，容量为2的切片，两个切片的底层数组是同一个。在我们使用append方法的时候，会检查切片是否已满（长度==容量），如果底层元素还没填满，那么append函数会更新底层数组并且长度加1。</p>
<p>​	在此示例中，s2未满，那么append会直接在后面将值进行插入</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221227155332209.png" alt="image-20221227155332209"  />
</p>
<p>​	在底层数组中，我们更新了最后一个数组元素，将其设置为10，如果我们打印所有的切片，我们将获得以下的输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">s1</span> = [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>]  <span style="color:#a6e22e">s2</span> = [<span style="color:#ae81ff">2</span>] <span style="color:#a6e22e">s3</span> = [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">10</span>]
</span></span></code></pre></div><p>​	这个时候切片的内容被修改了，虽然我们并没有直接更新s1[2]，或者s2[1]。我们应该牢记这一点，以避免出现意想不到的情况</p>
<p>​	让我们顺便看看这个原则的一个影响，对函数进行切片操作的结果，下面，我们初始化一个包含3个元素的切片，并调用一个仅包含前两个元素的函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Use s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Update s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>​	在此实现中，如果f只更新前两个元素，那么这样的更改对main中的切片可见，但是如果f调用了append ，他会更新切片的第三个元素，即使我们只传递了两个元素</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// [1 2 10]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_</span> = append(<span style="color:#a6e22e">s</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	如果我们不想让f去对第三个元素修改，我们有两种选择，第一是传递切片的副本，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sCopy</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>  copy(<span style="color:#a6e22e">sCopy</span>, <span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">sCopy</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">result</span> <span style="color:#f92672">:=</span> append(<span style="color:#a6e22e">sCopy</span>, <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Use result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Update s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	因为我们传递的是一个副本给f，即使这个函数调用append，也不会导致前两个元素范围之外的意外情况。但是这样的做法会导致代码难以阅读，并且需要添加额外的副本。如果切片很大，这会成为一个问题</p>
<p>​	第二个选项可用于将潜在副作用的范围限制为仅前两个元素。 此选项涉及所谓的完整切片表达式：s[low:high:max]。 此语句创建的切片类似于使用 s[low:high] 创建的切片，不同之处在于生成的切片的容量等于 max - low。 这是调用 f 时的示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Use s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">s</span> []<span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Update s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	这里，传递给 f 的切片不是 s[:2]，而是 s[:2:2]</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221227164849550.png" alt="image-20221227164849550"  />
</p>
<p>​	当传递s[:2:2]时，我们可以将效果范围限制在前两个元素，这样做还可以避免我们必须执行切片复制</p>
<p>​	在使用切片的时候，我们必须牢记，我们可能会遇到的一些意外情况。如果生成的切片长度小于其容量，追加可以改变原始切片。如果我们想限制可能的副作用的范围，我们可以使用切片副本或完成的切片表达式</p>
<h2 id="切片和内存泄漏">切片和内存泄漏<a hidden class="anchor" aria-hidden="true" href="#切片和内存泄漏">#</a></h2>
<p>​	本节将说明，对现有的切片或数组进行切割可能会导致内存泄漏，我们讨论两种情况：一种是容量泄漏，另一种与指针有关</p>
<h3 id="容量泄漏">容量泄漏<a hidden class="anchor" aria-hidden="true" href="#容量泄漏">#</a></h3>
<p>​	对与容量泄漏，我们想象一下实现自定义二进制协议，一条消息可以包含100万字节，前5个字节表示消息类型，在我们的代码中，我们使用这些消息，并且处于审计目的，我们希望将最新的1000种消息类型存储在内存中，以下是我们的函数骨架</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">consumeMessage</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">receiveMessage</span>() 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Do something with msg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">storeMessageType</span>(<span style="color:#a6e22e">getMessageType</span>(<span style="color:#a6e22e">msg</span>)) <span style="color:#75715e">// 存储至少1000条消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过对msg的切割计算消息类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getMessageType</span> (<span style="color:#a6e22e">msg</span> []<span style="color:#66d9ef">byte</span>)[]<span style="color:#66d9ef">byte</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">msg</span>[:<span style="color:#ae81ff">5</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	getMessageType函数通过对输入切片进行切割来计算消息类型，在测试的时候一切正常，但是在部署应用程序时，我们注意到我们的应用程序消耗了大约1GB的内存，这怎么可能？</p>
<p>​	msg[:5]对msg进行切片操作会创建一个长度为5的切片，但是，他的容量与初始切片相同，剩余的元素仍然分配在内存中，即使最终没有引用msg</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221227172035559.png" alt="image-20221227172035559"  />
</p>
<p>​	切片操作后，切片的底层数组仍然包含了100万字节，因此，如果我们在内存中保留1000条消息，我们将保留大概1GB</p>
<p>​	我们应该如何做去解决这个问题呢？我们可以通过对切片进行拷贝，而不是切片的切割</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getMessageType</span>(<span style="color:#a6e22e">msg</span> []<span style="color:#66d9ef">byte</span>) []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">msgType</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>    copy(<span style="color:#a6e22e">msgType</span>, <span style="color:#a6e22e">msg</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">msgType</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	 因为我们执行了复制，所以msgType是一个长度为5，容量为5的切片，无论我们收到的消息大小是多少，我们只存储消息类型的5个字节</p>
<p>​	根据经验，请记住对大切片或数组进行切割可能会导致潜在的高内存消耗。 剩余的空间不会被 GC 回收，尽管只使用了几个元素，但依然保留一个大的底层数组。 使用切片副本是防止这种情况的解决方案</p>
<h3 id="切片和指针">切片和指针<a hidden class="anchor" aria-hidden="true" href="#切片和指针">#</a></h3>
<p>​	让我们使用包含字节切片的 Foo 结构体来检查这个问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Foo</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">v</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们要在每个步骤后检查内存分配，如下所示</p>
<ol>
<li>分配 1,000 个 Foo 元素的切片</li>
<li>遍历每个 Foo 元素，并为每个元素分配 1MB 给 v 切片</li>
<li>调用 keepFirstTwoElementsOnly，只返回前两个元素使用切片，然后调用 GC</li>
</ol>
<p>我们想看看在调用保持 FirstTwoElementsOnly 和垃圾回收后内存的行为。 这是 Go 中的场景（我们复用了前面提到的 printAlloc 函数）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">foos</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">Foo</span>,<span style="color:#ae81ff">1_000</span>)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">foos</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">foos</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">v</span> : <span style="color:#a6e22e">make</span> ([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">1024</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printAlloc</span>()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">two</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">keepFirstTwoElementsOnly</span>(<span style="color:#a6e22e">foos</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GC</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printAlloc</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">KeepAlive</span>(<span style="color:#a6e22e">two</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">keepFirstTwoElementOnly</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>)[]<span style="color:#a6e22e">Foo</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">foos</span>[:<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printAlloc</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">MemStats</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">ReadMemStats</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d KB\n&#34;</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Alloc</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	在这个例子中，我们分配 foos 切片，为每个元素分配一个 1 MB 的切片，然后调用 keepFirstTwoElementsOnly 和 GC。 最后，我们使用runtime .KeepAlive 在垃圾回收后保留对两个变量的引用，这样它就不会被回收。
​	我们可能希望 GC 收集剩余的 998 个 Foo 元素和为切片分配的数据，因为这些元素无法再访问。 然而，事实并非如此。 比如代码可以输出如下</p>
<p>​	第一个输出分配了大约 83 KB 的数据。 确实，我们分配了 1000 个 Foo 的零值。 第二个结果为每个切片分配 1 MB，这会增加内存。 然而请注意，GC 在最后一步后没有收集剩余的 998 个元素。 什么原因？</p>
<p>​	在使用切片时必须牢记这条规则：<strong>若切片的元素类型是指针或带指针字段的结构体，那么元素将不会被GC回收</strong>。 在我们的示例中，因为 Foo 包含一个切片（切片是后备数组顶部的指针），所以不会回收剩余的 998 个 Foo 元素及其切片。 因此，即使无法访问这 998 个元素，只要引用了 keepFirstTwoElementsOnly 返回的变量，它们就会留在内存中。
​	有哪些选项可以确保我们不会泄露剩余的 Foo 元素？ 同样，第一个选项是创建切片的副本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">keepFirstTwoElementsOnly</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>) []<span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">Foo</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    copy(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">foos</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	因为我们复制了切片的前两个元素，GC 知道 998 个元素将不再被引用，现在可以收集了。
如果我们想保留 1,000 个元素的底层容量，还有第二种选择，即将剩余元素的切片显式标记为 nil</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">keepFirstTwoElementsOnly</span>(<span style="color:#a6e22e">foos</span> []<span style="color:#a6e22e">Foo</span>) []<span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">foos</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">foos</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">v</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">foos</span>[:<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	在这里，我们返回一个长度为 2、容量为 1,000 的切片，但我们将剩余元素的切片设置为 nil。 因此，GC 可以收集 998 个底层数组</p>
<p>​	哪个选项最好？ 如果我们不想将容量保持在 1,000 个元素，第一个选项可能是最好的。 然而，该决定也可以取决于元素的比例。 图 3.14 提供了一个我们可以选择的选项的可视化示例，假设一个切片包含 n 个元素，我们希望在其中保留元素。</p>
<p>​	第一个选项创建元素的副本。 因此，它必须从元素 0 迭代到 i。 第二个选项将剩余的切片设置为 nil，因此它必须从元素 i 迭代到 n。 如果性能很重要并且 i 比 0 更接近 n，我们可以考虑第二种选择。 这需要迭代更少的元素（至少，可能值得对这两个选项进行基准测试。</p>
<p>​	在本节中，我们看到了两个潜在的内存泄漏问题。 第一个是关于对现有切片或数组进行切片以保留容量。 如果我们处理大型切片并将它们重新切片以仅保留一小部分，则大量内存将保持分配状态但未使用。 第二个问题是，当我们对指针或具有指针字段的结构使用切片操作时，我们需要知道 GC 不会回收这些元素。 在这种情况下，两个选项要么执行复制，要么显式地将剩余元素或其字段标记为 nil</p>
<h2 id="低效的map初始化">低效的map初始化<a hidden class="anchor" aria-hidden="true" href="#低效的map初始化">#</a></h2>
<p>​	本节讨论一个类似于我们在切片初始化中看到的问题，但使用map。 但首先，我们需要了解有关如何在 Go 中实现map的基础知识，以了解为什么调整map初始化很重要。</p>
<h3 id="概念-1">概念<a hidden class="anchor" aria-hidden="true" href="#概念-1">#</a></h3>
<p>​	映射提供了键值对的无序集合，其中所有键都是不同的。 在 Go 中，映射是基于哈希表数据结构的。 在内部，哈希表是一个桶数组，每个桶是一个指向键值对数组的指针，如图所示。</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221229103143490.png" alt="image-20221229103143490"  />
</p>
<p>​	一个包含四个元素的数组支持图中的哈希表。 如果我们检查数组索引，我们会注意到一个由单个键值对（元素）组成的桶：“two”/2。 每个桶有八个元素的固定大小</p>
<p>​	每个操作（读取、更新、插入、删除）都是通过将键与数组索引相关联来完成的。 这一步依赖于哈希函数。 这个函数是稳定的，因为我们希望它在给定相同键的情况下始终返回相同的桶，在之前的示例中，hash(&ldquo;two&rdquo;)返回的是0.因此该元素存储在相关联的桶中索引为0的位置</p>
<p>​	如果我们插入另外一个元素，将key进行hash计算之后返回的是相同的索引，那么Go就会将其放进一个同样的桶中</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221229105625387.png" alt="image-20221229105625387"  />
</p>
<p>在插入一个已经满的桶（桶溢出）的情况下，GO会创建另一个包含八个元素的桶，并将前一个桶链接到它</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20221229105755204.png" alt="image-20221229105755204"  />
</p>
<p>​	对于读取、更新和删除，Go 必须计算相应的数组索引。 然后 Go 依次遍历所有键，直到找到提供的键。 因此，这三个操作的最坏情况时间复杂度为 O(p)，其中 p 是桶中元素的总数（默认为一个桶，溢出时为多个桶）</p>
<h3 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h3>
<p>​	为了理解低效的map初始化问题，让我们创建一个包含了三个元素的map[string]int类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;1&#34;</span>:<span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;2&#34;</span>:<span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;3&#34;</span>:<span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre><code>在内部，这个map底层的数组的每个索引只对应了一个桶。如果我们存放1百万个元素会发生什么？在这种情况下，一个桶肯定是不够的，也就是说在最糟糕的情况下，会有成千上万个桶，而找到一个键意味着要遍历数千个桶
</code></pre>
<p>​	当map进行扩容的时候，它的桶数量会增长一倍，那么map扩容的条件是什么？</p>
<ul>
<li>桶中项目的平均数量（称为负载因子=元素数量➗桶数量）大于常数值，这个常量等于6.5（在未来的版本中可能会变）</li>
<li>溢出的桶过多（包含超过八个元素）</li>
</ul>
<p>​	当map增长的时候，所有的键都会被再次分配给所有的桶。这就是为什么在最坏的情况下，插入一个键可能是一个O(n)操作，其中n是map中元素的总数</p>
<p>​	我们知道，在使用切片的时候，如果我们预先知道添加到切片元素中的数量，就可以使用给定的大小或容量对其进行初始化。这就避免了不断重复的昂贵的切片增长操作。实际上，我们也可以使用make内置函数在创建map的时候提供初始化大小。例如我们需要创建一个包含100万个元素的map，我们可以这样</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span>make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1_000_000</span>)
</span></span></code></pre></div><p>​	对于map，我们可以只给内置函数make一个初始大小而不是容量，就像切片一样。因此，只有一个参数。</p>
<p>​	通过指定大小，我们提供了一些预期元素数量的提示，在内部，使用适当数量的桶区创建map以存储100万个元素，这样就节省了大量的计算时间，因为map不需要动态的创建桶和处理平衡桶</p>
<p>​	此外，指定大小n并不意味着只存在一个存放n个元素的map，如果我们需要我们依然可以添加多于n个元素。</p>
<p>​	为了理解为什么指定大小很重要，我们运行两个基准测试，第一个是插入100万个元素而不设置初始大小，第二个是使用初始大小创建map</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> 		BenchmarkMapWithoutSize-4     <span style="color:#ae81ff">6</span>    <span style="color:#ae81ff">227413490</span> ns/op
</span></span><span style="display:flex;"><span>    BenchmarkMapWithSize-4       <span style="color:#ae81ff">13</span>     <span style="color:#ae81ff">91174193</span> ns/op
</span></span></code></pre></div><p>​	具有初始大小的map快了大约60%，通过提供初始大小，我们可以减少map的扩容</p>
<p>​	因此，就像切片一样，如果我们预先知道map包含的元素数量，我们应该通过提供初始大小来创建他，这样可以避免map的扩容，map的扩容在计算方面非常的繁重。因为它需要重新分配足够的空间并平衡所有的元素</p>
<h2 id="内存泄漏">内存泄漏<a hidden class="anchor" aria-hidden="true" href="#内存泄漏">#</a></h2>
<p>​	在我们使用map的时候，我们需要了解地图如何增长和缩容的一些重要特征。让我们深入研究这个问题，以防止可能导致的内存泄漏问题。</p>
<p>​	首先，为了查看此问题的具体示例，让我们设计一个使用map的场景</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>][<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">byte</span>)
</span></span></code></pre></div><p>​	m中的每个值都是一个长度为128的byte数组，</p>
<ul>
<li>分配一个空map</li>
<li>添加100万个元素</li>
<li>删除所有的元素，然后运行GC</li>
</ul>
<p>​	在每一步之后，我们都要打印堆的大小（这次使用MB),用来查看这个示例的内存表现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1_000_000</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>][<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">byte</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printAlloc</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">readBytes</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printAlloc</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		delete(<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GC</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printAlloc</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">KeepAlive</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">readBytes</span>() [<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">128</span>]<span style="color:#66d9ef">byte</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printAlloc</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">MemStats</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">ReadMemStats</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%d MB\n&#34;</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Alloc</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	我们分配一个空的map，然后添加100万个元素，紧接着我们将100万个元素删除，然后运行GC。我们还使用runtime.KeepAlive保留对map的应用，这样map就不会被回收，在运行这个示例之后下面的输出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#a6e22e">MB</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">461</span> <span style="color:#a6e22e">MB</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">293</span> <span style="color:#a6e22e">MB</span>
</span></span></code></pre></div><p>​	通过上面的输出，我们可以观察到。起初，堆大小是最小的。当我们向map中添加了100万个元素后它会显著增长。但是，我们希望在删除所有的元素后堆的大小会减少。在最后，我们虽然GC收集了所有的元素，但是堆的大小仍然是293MB。虽然内存缩小了，但是并不像我们预期的那样，这是为什么？</p>
<p>​	我们上一节中有说到map是由八个元素的桶组成，在底层，map是指向runtime.hmap结构的指针，该结构包含多个字段，包括一个B字段，该字段表示映射中的桶数量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// A header for a Go map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hmap</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// Make sure this stays in sync with the compiler&#39;s definition.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">count</span>     <span style="color:#66d9ef">int</span> <span style="color:#75715e">// # live cells == size of map.  Must be first (used by len() builtin) 当前哈希表中的元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">flags</span>     <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">B</span>         <span style="color:#66d9ef">uint8</span>  <span style="color:#75715e">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)  当前哈希表持有的buckets的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">noverflow</span> <span style="color:#66d9ef">uint16</span> <span style="color:#75715e">// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">hash0</span>     <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// hash seed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">buckets</span>    <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">oldbuckets</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// previous bucket array of half the size, non-nil only when growing 扩容时用于保存之前的buckets的字段，大小是当前buckets的一半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">nevacuate</span>  <span style="color:#66d9ef">uintptr</span>        <span style="color:#75715e">// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">extra</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mapextra</span> <span style="color:#75715e">// optional fields
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>​	当我们添加了100万个元素后，B的值为18，就是2^18=262144个桶，但是当我们清除100万个元素的时候，B的值仍然是18，因此map中依然包含了相同数量的桶</p>
<p>​	原因是map中的桶数量不能缩减，因此，从map中删除元素不会影响现有桶的数量，它只是将桶中的槽清零。map只能增长并拥有更多的桶，它永远不会缩小</p>
<p>​	在前面的示例中，我们从461MB减少到293MB，因为元素已经被回收，但是运行GC不会影响map本身。以及额外的桶的数量（因为溢出而创建的桶）</p>
<p>​	我们可以讨论一下map不能收缩何时会成为一个问题。假如我们使用map[int]byte构建缓存，此map包含没个用户的ID(int)，一个128byte的序列。现在，假设我们想存储最后1000个客户。map的大小保持不变</p>
<p>​	假设我们要存储一小时的数据，同时，我们公司决定在黑色星期五进行一次大促销：在一个小时内，我们可能有数百万客户连接到我们的系统，但是在黑色星期五之后的几天，我们的map将包含高峰时段相同数量的桶。这也就解释了为什么我在遇到这样的情况下不会显著减少的高内存消耗</p>
<p>​	如果我们不想手动重启服务来清理map消耗的内存量，有什么解决方案？一种解决方案是定期重新创建当前map的副本。例如，每间隔一小时，我们构建一个新的map，复制所有元素，并释放之前的map。这样的缺点是在复制之后直到下一次垃圾收集，我们可能会在短时间内消耗两倍的内存</p>
<p>​	另一种解决方案是更改map的存储类型，将<code>map[int][128]byte</code>改成<code>map[int]*[128]byte</code>。这样并没有解决大量桶的情况，但是每个桶内的元素变成了保留指针的大小（64位系统上是8字节，32位系统上是4字节），而不是128字节。</p>
<p>​	下表展示了不同情况下没个步骤后的内存消耗</p>
<p><img loading="lazy" src="https://img.ethanleo.top/uPic/image-20230103213748178.png" alt="image-20230103213748178"  />
</p>
<p>​	正如图中所展示的，删除所有元素后,<code>map[int]*[128]byte</code>类型所需要的内存明显减少，此外，在这种情况下，由于优化减少了内存，所以在高峰的时候所需要的内存大大减少</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>如果键或值超过128字节，GO不会将其直接存储在映射桶中，而是会存储一个指针来引用键或值
</span></span></code></pre></div><p>​	就像我们看到的那样，向map中添加n个元素然后删除意味着在内存中保留了相同数量的桶。所以，我们得知道，因为Go中的map大小只会增加，所以它的内存消耗也会增加，并没有自动策略来缩小它。如果这导致了高内存消耗，我们可以尝试不同的选项来进行优化，例如强制Go创建新的map或使用指针来进行存储</p>
<h2 id="错误地比较值">错误地比较值<a hidden class="anchor" aria-hidden="true" href="#错误地比较值">#</a></h2>
<p>​	比较值是软件开发中的常见操作。我们实现比较操作经常的逻辑是：编写一个函数来比较两个对象，或者比较一个值与期望值，等等。我们第一直觉可能是用<code>==</code>运算符，但将在我们本节中看到的那样，情况并非如此，那么我们什么时候使用<code>==</code>比较合适，有哪些替代方案呢？</p>
<p>​	让我们从一个具体的例子开始。我们创建一个基本的<code>customer</code>结构并使用<code>==</code>来比较两个实例。你认为这段代码输出应该是什么呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">customer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">cust1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">cust2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cust1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">cust2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	比较两个<code>customer</code>的实例，它会打印true，现在，如果我们稍微修改<code>customer</code>，在其中添加切片类型的字段会发生什么</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">customer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span>         <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">operations</span> []<span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cust1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cust2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cust1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">cust2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	我们希望代码可以输出true，然而，这样的代码是不会通过编译的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>invalid operation: cust1 <span style="color:#f92672">==</span> cust2 <span style="color:#f92672">(</span>struct containing <span style="color:#f92672">[]</span>float64 cannot be compared<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>​	这样的错误与<code>==</code>和<code>!=</code>运算符的工作方式有关，这些运算符不适用于切片或者map。因此，因为<code>customer</code>结构包含一个切片，所以它不会通过编译</p>
<p>​	了解如果使用<code>==</code>和<code>!=</code>进行有效比较至关重要。我们可以在比较的操作数上使用这样的运算符：</p>
<ul>
<li><em>Booleans</em> 比较两个布尔值是否相等</li>
<li><em>Numerics (int, float, and complex types)</em> 比较两个数字是否相等</li>
<li><em>Strings</em> 比较两个字符串是否相等</li>
<li><em>Channels</em> 比较两个<code>channel</code>是否由同一个make创建或者两者是否都为nil</li>
<li><em>Interfaces</em> 比较两个接口是否有相同的动态类型和相同的动态值或者两者都为nil</li>
<li><em>Points</em> 比较两个指针是否指向内存中的值是否相同或者两者都为nil</li>
<li><em>structs and arrays</em> 比较他们是否相同的类型</li>
</ul>
<p>​	最后一个示例中，我们的代码无法编译，因为结构体中具有切片字段，我们还需要知道关于<code>any</code>类型下的比较运算符<code>==</code>和<code>!=</code>，看下面的示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">any</span> = <span style="color:#ae81ff">3</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">any</span> = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">b</span> )
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>true
</span></span></code></pre></div><p>​	但是如果我们初始化两个customer类型（包含切片字段）并将值分配给<code>any</code>类型，会有什么情况</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">customer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span>         <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">operations</span> []<span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cust1</span> <span style="color:#a6e22e">any</span> = <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cust2</span> <span style="color:#a6e22e">any</span> = <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">cust1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">cust2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">panic</span>: <span style="color:#a6e22e">runtime</span> <span style="color:#66d9ef">error</span>: <span style="color:#a6e22e">comparing</span> <span style="color:#a6e22e">uncomparable</span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">main</span>.<span style="color:#a6e22e">customer</span>
</span></span></code></pre></div><p>​	上面的代码可以通过编译，但是在运行的时候依然会panic</p>
<p>​	考虑到上面的这些情况，如果我们必须比较两个切片、两个map，或者包含不可以比较的结构，有哪些选择？如果我们坚持使用标准库，我们可以选择reflect包来进行比较</p>
<p>​	反射是元编程的一种形式，它指的是应用程序自省和修改其结构和行为的能力。例如，在Go中，我们可以使用</p>
<p>reflect.DeepEqual，该函数通过递归遍历两个值来确定两个元素是否深度相等，它接受的元素是基本类型加上数组、结构体、切片、map、指针、接口和函数</p>
<p>​	让我们通过一个示例来演示reflect.DeepEqual</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">customer</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">id</span>         <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">operations</span> []<span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cust1</span> = <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cust2</span> = <span style="color:#a6e22e">customer</span>{<span style="color:#a6e22e">id</span>: <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#a6e22e">operations</span>: []<span style="color:#66d9ef">float64</span>{<span style="color:#ae81ff">1.</span>}}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">cust1</span>, <span style="color:#a6e22e">cust2</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	即使customer结构体中包含了不可直接比较的切片类型，通过<code>reflect.DeepEqual</code>依然可以进行比较，上面的代码可以输入true</p>
<p>​	但是，在使用reflect.DeepEqual时候需要注意两点，首先，它区分了空集合和nil集合，如果我们想要比较两个解组操作的结果（例如从JSON到Go结构），我们可能希望这样的是存在差异的。</p>
<p>​	另外就是，因为这个函数使用了反射，它是在运行时来判断这个值是怎么形成的，所以它会有性能损失。所以平均来说<code>reflect.DeepEqual</code>比<code>==</code>慢100倍</p>
<p>​	如果性能是一个比较关键的因素，那么我们会去实现自己的比较方法，来进行两个customer实例的比较</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">customer</span>)<span style="color:#a6e22e">equal</span>(<span style="color:#a6e22e">b</span> <span style="color:#a6e22e">customer</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">id</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">id</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">operations</span>) <span style="color:#f92672">!=</span> len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">operations</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">operations</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">operations</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">operations</span>[<span style="color:#a6e22e">i</span>]{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> 		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>​	在此代码中，我们通过对customer结构的不同字段进行自定义检查来实现我们自己的比较方法。在由100个元素组成的切片上运行本地基准测试表明，我们自定义的equal方法比reflect.DeepEqual快约96倍</p>
<p>​	通常，我们应该记住<code>==</code>运算符非常有限。例如，它不适用于切片和map比较。在大多数情况下，使用reflect.DeepEqual是一种解决方案，但是主要问题是性能损失。</p>
<p>​	但是，如果性能在我们的程序中至关重要，那么实现我们自定义的方法可能是最佳解决方案</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">My New Hugo Site</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
